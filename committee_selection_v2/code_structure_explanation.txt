This is a short text explaining the different part of the code:

4 main .py files:
simulation.py: where the simulation is run, has method one_round that runs like the flowchart

block.py: defines a block class, used to create indiviual blocks as block objects

process.py: defines an individual process, so every individ. process is an object of this class

reputation_calculation.py: holds functions that are used to create leaders and committees, either based
                           on reputation or random (used to test stuff). these functions take certain arguments and
                           return a committee (list of process objects), or a leader (individ. process object). these
                           functions are used by the one_round methods in simulation class

Simulation class in simulation.py:
2 main methods: one_round() and distribute_reward()

one_round:
there are 3 different versions but only two are relevant one_round_rebop which is my version of arians original simulation
of rebop and one_round_v2 which includes selection of committee based on reputation. They both use the leader_reputation
 function to select a leader based on reputation but they differ on how they choose the committee. the origininal rebop
 has a constant committee and the v2 has committee selction based on reputation.

logic of one_round methods:
1. leader is selceted from pool/committee
2. committee is selceted (for v2), (as a list of processes)
3. leader proposes a new block h
4. the new committee are saved in the block (h), through the committee_at_block variable of the block object
5. the committee members vote on the block (h), for each voter the votes method in process.py is called, and their votes
 are added to the initial_votes list in the block object. this variable is used to save all the votes cast by the comm.memb.
6. if atleast 2/3 of the committe has voted, the block (h) is appended to the blockchain
7. then current leader handles/validates the votes cast on block h-1, the validating/omission of votes happens in the
leader_vote_collection method in process.py. all the votes he decides to validate (not omit) will be appended to the
list of signatures in the block (h-1). so if the leader omits votes because he is of type "colluding" or "byzantine", the
signatures list will be shorter/smaller than the list of initial votes, the differences are the omissions.
8. then in the end the rewards are distributed for block h-1, the rewarding is based on the signatures and not on the
list of initial_voters. the voters recorded in signatures get their portion of the reward pool, (100 by default) and the
 leader gets his bonus

reputation_calculation.py

the calculation for leader reputation is done in the leader_reputation function, it takes in the pool of processes among
other things, and return a leader (process object) works the same as arians original rebop

the calculation/selection of committee members based on reputation is done by the committee_reputation function. It also
takes in a pool of processes (a list) among other things, and return a committee chosen based on reputation (a list)
the reputation for committee selection is calculated based on how often he votes when he has had the chance in the last
T rounds, a percentage. feks .9 means he voted 9 out of 10 possible times.



















